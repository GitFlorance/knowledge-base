# Table of contents
1. [Promise](#Promise)
1. [Async/Await](#Async/Await)
1. [Event loop](#event-loop)
    * [Microtasks](#Microtasks)
    * [Blocking tasks](#blocking-tasks)
    
    
## Promise

Promise – это специальный объект, который содержит своё состояние.
Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») 
или rejected («выполнено с ошибкой»).

Promise переводится в состояние fulfilled (снимает задержку) 
при вызове одного из двух методов: 
- resolve(response) - возвращает переданное ему как аргумент значение
- reject(error) - работает аналогично throw 

```js
const promise = new Promise(function(resolve, reject) {
    // вызов асинхронной функции

    // resolve(результат) при успешном выполнении
    // reject(ошибка) при ошибке
});
```

Промис имеет методы, вызываемые после разрешения промиса (“Thenable” object),
которые в свою очередь также возвращают промис. 
Таким образом их можно объединять в цепочки

```js
const test = new Promise((resolve,reject) =>{
    // reject('test reject');
    // or
    // resolve('test resolve');
}).then((value)=>{
    // не будет вызван, если промис будет разрешен с ошибкой
    console.log('promise was resolved',value);
    return value + 'first then';
}).catch((error)=>{
    // будет вызван, если промис будет разрешен успешно
    console.log('promise was rejected',error);
    return error + 'cached'
}).finally(()=>{
    // не изменяет возвращаемое промисом значение
    // и не имеет доступа к результату работы цепи промисов
    console.log('called in any case, just do something');
}).then((value)=>{
    console.log('called after all and in any case');
    return value + 'second then'
});
```

Выполнение промисов можно запустить параллельно
```js
const awaitAll = function(){
    return Promise.all([async1(), async2()]);
}
```
**[⬆ back to top](#table-of-contents)**


## Async/Await

- **async** указанный перед функцией - гарантирует, что эта функция вернет промис.
- **await** заставит интерпретатор JavaScript ждать до тех пор,
пока промис справа от await не выполнится. Работает только в теле **async** функции

```js
async function f() {

    const promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve("готово!"), 1000)
    });

    const result = await promise; // будет ждать, пока промис не выполнится (*)

    alert(result); // "готово!"
}
```

Аснхронная функция, использующая промис, должна его вернуть:
```js
const promise = function(){
    return new Promise(function(resolve, reject) {});
};

async function f() {
    const result = await promise();

    alert(result); // "готово!"
}
```
**[⬆ back to top](#table-of-contents)**


## Event loop

Задачи поступают на выполнение – движок выполняет их – затем ожидает новые задачи.
Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.

1. Выбрать и исполнить старейшую задачу из очереди макрозадач.
1. Пока очередь микрозадач не пуста: - выбрать из очереди и исполнить старейшую микрозадачу
1. Отрисовать изменения страницы, если они есть.
1. Если очередь макрозадач пуста – подождать, пока появится макрозадача.
1. Перейти к шагу 1.

## Microtasks

Асинхронные задачи требуют правильного управления. 
Для этого стандарт предусматривает внутреннюю очередь PromiseJobs,
более известную как «очередь микрозадач (microtask queue)»

- Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
- Выполнение задачи происходит только в том случае,
 если ничего больше не запущено - то есть "call stack" пуст

Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally попадают в очередь. 
Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, 
когда он освободится от выполнения текущего кода.

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем,
как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.
Все микрозадачи завершаются до обработки каких-либо событий или рендеринга,
или перехода к другой макрозадаче.

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

1. code появляется первым, т.к. это обычный синхронный вызов.
1. promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
1. timeout появляется последним, потому что это макрозадача.

## Blocking tasks

Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. 
Не имеет значения, сколь долго выполняется задача. Изменения в DOM отрисовываются только после того,
как задача выполнена.

Если задача выполняется очень долго, то браузер не может выполнять другие задачи,
обрабатывать пользовательские события, поэтому спустя некоторое время браузер предлагает «убить» долго выполняющуюся задачу.
Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.

Блокирующую задачу можно "разбить на части", после завершения выполнения первой части, 
выполнение следующей откладывается. Например посредством вызова в качестве коллбек функции setTimeout.
Таким образом вызов следующей части попадает в очередь задач, откуда вернется в стэк выполнения,
когда тот очистится от задач, накопившихся за время выполнения первой части.


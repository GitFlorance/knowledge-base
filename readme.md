# Table of contents
1. [Promise](#Promise)
    * [Promise.then()](#Promise.then())
    * [Promise.all()](#Promise.all())
1. [Async/Await](#Async/Await)
1. [Event loop](#event-loop)
    * [Microtasks](#Microtasks)
    * [Macrotasks](#Macrotasks)
    * [Browser`s render queue](#browser’s-render-queue)
        * [window.requestAnimationFrame()](#window.requestAnimationFrame())
    * [Blocking tasks](#blocking-tasks)
    * [Execution context](#execution-context)
1. [Browser events](#browser-events)
    * [Bubbling](#bubbling)
    * [stopPropagation](#stopPropagation)
    * [Capturing](#Capturing)
    
   
    
# Promise

Promise – это специальный объект, который содержит своё состояние.
Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») 
или rejected («выполнено с ошибкой»).

Promise не блокирует работу движка браузера (интерфейс страницы попрежнему интерактивен),
дожидаясь завершения работы асинхронной функции. Но результат выполнения промиса можно получить в коде
в любой момент времени, переведя его в состояние fulfilled или rejected.
Это происходит при вызове одного из двух методов: 
- resolve(response) - возвращает переданное ему как аргумент значение
- reject(error) - работает аналогично throw 

```js
const promise = new Promise(function(resolve, reject) {
    // вызов асинхронной функции

    // resolve(результат) при успешном выполнении
    // reject(ошибка) при ошибке
});
```

## Promise.then()

Промис имеет методы, вызываемые после разрешения промиса (“Thenable” object),
которые в свою очередь также возвращают промис. 
Таким образом их можно объединять в цепочки

```js
const test = new Promise((resolve,reject) =>{
    // reject('test reject');
    // or
    // resolve('test resolve');
}).then((value)=>{
    // не будет вызван, если промис будет разрешен с ошибкой
    console.log('promise was resolved',value);
    return value + 'first then';
}).catch((error)=>{
    // будет вызван, если промис будет разрешен успешно
    console.log('promise was rejected',error);
    return error + 'cached'
}).finally(()=>{
    // не изменяет возвращаемое промисом значение
    // и не имеет доступа к результату работы цепи промисов
    console.log('called in any case, just do something');
}).then((value)=>{
    console.log('called after all and in any case');
    return value + 'second then'
});
```

Пример использования - цепочка асинхронных запросов, 
в которой каждая последующая функция использует результат выполнения предыдущей.
Такой подход позволит избежать "callback hell":

```js
const getUserAvatar = getUserByName('name').then(function (user) {
    // Функция getUserAccountById возвращает promise,
    // результат которого попадет в следующий then
    return getUserAccountById(user.id);
  })
  .then(function (userAccount) {
    // Я знаю все о пользователе!
    return userAccount.avatar;
  });
```

## Promise.all()

Выполнение промисов можно запустить параллельно, а затем, 
когда завершится выполнение самой длительной из них, 
обработать полученные результаты всех функций:
```js
const async1 = new Promise((resolve, reject) => { 
  setTimeout(resolve, 1000, "one"); 
}); 
const async2 = new Promise((resolve, reject) => { 
  setTimeout(resolve, 2000, "two"); 
});

Promise.all([async1, async2]).then((values)=>{
    console.log(values);
})

// ['one','two']
```
**[⬆ back to top](#table-of-contents)**

# Async/Await

- **async** указанный перед функцией - гарантирует, что эта функция вернет промис.
- **await** заставит интерпретатор JavaScript ждать до тех пор,
пока промис справа от await не выполнится. Работает только в теле **async** функции

```js
async function f() {

    const promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve("готово!"), 1000)
    });

    const result = await promise; // будет ждать, пока промис не выполнится (*)

    alert(result); // "готово!"
}
```

Аснхронная функция должна вернуть промис:
```js
const promise = function(){
    return new Promise(function(resolve, reject) {});
};

async function f() {
    const result = await promise();

    alert(result); // "готово!"
}
```
**[⬆ back to top](#table-of-contents)**

# Event loop

Задачи поступают на выполнение – движок выполняет их – затем ожидает новые задачи.
Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.

- Heap  — объекты собраны в кучу, которая есть ни что иное, 
как название для наименее структурированной части памяти.
- Call Stack — репрезентация единственного потока выполнения JavaScript-кода. 
Вызовы функций помещаются в стек.
- Browser or Web API’s — встроены в браузер и способны предоставлять данные из браузера 
и окружающей компьютерной среды и давать возможность выполнять с ними полезные и сложные вещи.
Они не являются частью языка JavaScript, но они построены на его основе и предоставляют вам супер силы, 
которые можно использовать в JavaScript коде. 

```js
function main() {
    console.log('A');

    setTimeout(function exec() {
      console.log('B')
    }, 0);
    
    Promise.resolve()
      .then(() => alert('C'));

    console.log('D');
}

// A
// D
// C
// B
```

Как устроен "event loop":
1. Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.
Очередь, которую формируют такие задачи, называют "macrotask queue" (очередь макрозадач). Из этой очереди
задачи поступают по одной на выполнение в "call stack"(стек вызовов).
1. Функция main() находится на дне стека - она будет считаться выполненной после выполнения вложенных функций.
Так и формируется стек вызовов: поверх вызываемой функции помещается вложенная, 
поверх нее, функция вложенная во вторую и т.д. Выполнение начинается с верхней - наиболее глубоко вложенной.
1. setTimeout обращается к браузерном API и передает ему коллбек и задержку. 
Таймер выполняется вне "Main Thread"(основного потока). 
По истечении времени задержки таймер помещает коллбек в "callback queue"(очередь обратных вызовов).
1. После выполнения последней макрозадачи, call stack очищается. 
1. Тогда "event loop" обращается к "microtask queue"(очереди микрозадач). Пока очередь микрозадач не пуста, 
"event loop" будет перемещать микрозадачи в "call stack", 
начиная с самой старой(первой попавшей в "microtasks queue") и выполнять их.
1. После выполнения всех микрозадач в очереди, "event loop" обращается к "render queue". 
Задачи от "render queue" оптимизируются браузером и, если он посчитает, что в этом цикле не нужно ничего перерисовывать, 
то "event loop" просто пойдет дальше. 
1. После этого "event loop" обращается к "callback queue". Выполнение задач из callback queue также начинается с самой первой из них.
Задачи из "callback queue"  перемещаются в "call stack", только если тот пуст. 
У различных макрозадач выше приоритет на выполнение, поэтому "event loop" может переключиться на макрозадачи
до того, как выполнит все задачи из "callback queue'. Круг замкнулся.

## Macrotasks
Макротасками - задачами, называются функции, попадающие в "call stack" из heap, 
то есть вызываемые из кода, а также "browse events"(браузерные события). Их великое множество:
- клики мышкой;
- скроллинг;
- ввод с клавиатуры;
- загрузка скриптов;
- CSS анимации;
- и тд.

Поэтому так важно не блокировать "event loop", иначе вызовы эвентов, 
отвечающих за интерактивность страницы могут зависнуть в ожидании, когда "call stack" будет очищен.

## Microtasks
Асинхронные задачи требуют правильного управления. 
Для этого стандарт предусматривает внутреннюю очередь PromiseJobs,
более известную как "microtask queue"(очередь микрозадач).

- Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
- Выполнение задачи происходит только в том случае,
 если ничего больше не запущено - то есть "call stack" пуст

Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally попадают в очередь. 
Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, 
когда он освободится от выполнения текущего кода.

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем,
как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.
Все микрозадачи завершаются до обработки каких-либо событий или рендеринга,
или перехода к другой макрозадаче.

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

1. code появляется первым, т.к. это обычный синхронный вызов.
1. promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
1. timeout появляется последним, потому что это макрозадача.


```js
function foo() {
  Promise.resolve().then(foo);
}

foo();
```
Вызов foo помещает в call stack выражения из microtasks queue, а они выполняются все, пока не закончатся. 
А это значит, что пока Event Loop не закончит их, перейти к следующей задаче он не сможет. 

## Browser`s render queue
Браузер старается обновлять содержимое страницы с частотой обновления дисплей - 60Гц.
Процесс перерисовки страницы каждые ~16.667ms называется "render cycle"(цикл рендера).

Браузер планирует новое событие перерисовки каждый цикл рендеринга в 
"browser’s the render queue"(очереди рендеринга браузера).

Если функции внутри стека вызовов JavaScript не завершают свое выполнение в этом цикле рендеринга, 
тогда не остается достаточно времени для выполнения событий перерисовки.

### window.requestAnimationFrame()

Это метод, который указывает браузеру на то, что вы хотите произвести анимацию, 
и просит его запланировать перерисовку на следующем кадре анимации. 
В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой.

```js
let start = null;
const element = document.getElementById('SomeElementYouWantToAnimate');

function step(timestamp) {
  if (!start) start = timestamp;
  const progress = timestamp - start;
  element.style.transform = 'translateX(' + Math.min(progress / 10, 200) + 'px)';
  if (progress < 2000) {
    window.requestAnimationFrame(step);
  }
}

window.requestAnimationFrame(step);
```

## Blocking tasks

Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. 
Не имеет значения, сколь долго выполняется задача. Изменения в DOM отрисовываются только после того,
как задача выполнена.

Если задача выполняется очень долго, то браузер не может выполнять другие задачи,
обрабатывать пользовательские события, поэтому спустя некоторое время браузер предлагает «убить» долго выполняющуюся задачу.
Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.

Блокирующую задачу можно "разбить на части", после завершения выполнения первой части, 
выполнение следующей откладывается. Например посредством вызова в качестве коллбек функции setTimeout.
Таким образом вызов следующей части попадает в очередь задач, откуда вернется в стэк выполнения,
когда тот очистится от задач, накопившихся за время выполнения первой части.

## Execution context
Как только скрипт попадает в интерпретатор, формируются глобальный контекст и глобальная область видимости, 
в которой держится Variable Object, или VO — объект переменных.

Когда заполняется "call stack", создается глобальный контекст выполнения, 
который является глобальной средой, в которой выполняется наш код JavaScript.
Также для каждой функции, имеющей вложенные объявления переменных и функций, 
создается локальный контекст выполнения

Контекст выполнения - это абстрактная концепция окружения, где код анализируется и выполняется. 
Всякий раз, когда в JavaScript выполняется код, это происходит внутри контекста выполнения.

setTimeout выводит контекст исполнения функции из синхронного потока, помещая его в event loop. 
То же самое происходит и с регистрацией событий. Мы можем подписаться на событие при помощи функции addEventListener. 
Передавая функцию обратного вызова — callback, добавляем её в список функций, 
которые должны быть вызваны при срабатывании этого события.

# Browser events

Событие – это сигнал от браузера о том, что что-то произошло. 
Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).
Вот список самых часто используемых DOM-событий, пока просто для ознакомления:

События мыши:
* click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
* contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
* mouseover / mouseout – когда мышь наводится на / покидает элемент.
* mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
* mousemove – при движении мыши.

События на элементах управления:
* submit – пользователь отправил форму <form>.
* focus – пользователь фокусируется на элементе, например нажимает на <input>.

Клавиатурные события:
* keydown и keyup – когда пользователь нажимает / отпускает клавишу.

События документа:
* DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

CSS events:
* transitionend – когда CSS-анимация завершена.

Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.
Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.

```js
const elem = document.getElementById('btn');

elem.addEventListener( "click" , () => alert('hello world'));
```

## Bubbling
Всплытие эвента. При наступлении события обработчики сначала срабатывают на самом вложенном элементе, 
затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.

```html
<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

При клике по абзацу, будут вызваны все 3 обработчки в порядке: **p**, **div**, **form**.

Самый глубокий элемент, который вызывает событие, называется «целевым» 
или «исходным» элементом и доступен как **event.target**. 
Элемент, на котором сработал обработчик доступен через **this**, **event.currentTarget**.

```js
elem.addEventListener( "click" , function(event){
    event.currentTarget.classList.add('reached');
    this.classList.add('another-reached');
});

// this === event.currentTarget === elem
```

## stopPropagation
Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.
Для остановки всплытия нужно вызвать метод event.stopPropagation().

```html
<body onclick="alert('сюда обработка не дойдёт')">
  <button onclick="event.stopPropagation()">Кликни меня</button>
</body>
```

## Capturing
В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение».
Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.
Строго говоря, стандарт выделяет целых три стадии прохода события:

1. Событие сначала идёт сверху вниз. Эта стадия называется «стадия перехвата» (capturing stage).
1. Событие достигло целевого элемента. Это – «стадия цели» (target stage).
1. После этого событие начинает всплывать. Это – «стадия всплытия» (bubbling stage).

Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener:
*   Если аргумент true, то событие будет перехвачено по дороге вниз.
*   Если аргумент false, то событие будет поймано при всплытии.
